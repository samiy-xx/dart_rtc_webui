// Auto-generated from chatcomponent.html.
// DO NOT EDIT.

library chatcomponent;

import 'dart:html' as autogenerated;
import 'dart:svg' as autogenerated_svg;
import 'package:web_ui/web_ui.dart' as autogenerated;

import 'dart:html';

import 'dart:async';

import 'package:web_ui/web_ui.dart';

import 'package:dart_rtc_common/rtc_common.dart';

import 'package:dart_rtc_client/rtc_client.dart';

part '../messagetype.dart';

part '../chatmessage.dart';

part '../user.dart';

part '../tabs.dart';

class ChatComponent extends WebComponent {
  
  /** Autogenerated from the template. */
  
  /**
  * Shadow root for this component. We use 'var' to allow simulating shadow DOM
  * on browsers that don't support this feature.
  */
  var _root;
  autogenerated.DivElement __chat_input, __chat_messages, __chat_tabs, __chat_users;
  autogenerated.Element __e13, __iterate_tabs, __iterate_users;
  autogenerated.Template __t;
  
  ChatComponent.forElement(e) : super.forElement(e);
  
  void created_autogenerated() {
    _root = createShadowRoot();
    __t = new autogenerated.Template(_root);
    _root.innerHtml = '''
    
    <div class="chat_container">
    
    <div class="container_right">
    <div id="chat_users">
    <template id="iterate_users" style="display:none"></template>
    </div>
    </div>
    
    <div class="container_left">
    <div id="chat_tabs">
    <ul>
    <template id="iterate_tabs" style="display:none"></template>
    </ul>
    </div>
    <div id="chat_messages">
    <template id="__e-13" style="display:none"></template>
    </div>
    </div>
    </div>
    
    <div id="chat_input"></div>
    
    <style>
    .chat_container {
      height: auto;
      overflow: hidden;
      border: 1px solid #000;
      -moz-box-shadow:0px 0px 10px 3px #777777;
      -webkit-box-shadow:0px 0px 10px 3px #777777;
      box-shadow:0px 0px 10px 3px #777777;
      -webkit-border-radius: 5px; /* for safari */
      -moz-border-raidus: 5px; /* for firefox < 4 */
      border-radius: 5px; /* for all other that support it */
    }
    
    .container_left {
      width: auto;
      overflow: hidden;
    }
    
    .container_right {
      float: right;
      width: 200px;
      border-left: 1px solid #000;
    }
    
    #chat_users {
      height: 400px;
      padding: 3px;
      overflow:auto
    }
    
    .user_entry {
      cursor : pointer;
      background: #fff;
    }
    
    .user_entry:hover {
      background: #ddd;
    }
    
    #chat_messages {
      height: 370px;
      overflow:auto
    }
    
    #chat_input {
      border: 1px solid #000;
      height:20px;
      margin-top: 5px;
      -moz-box-shadow:0px 0px 10px 3px #777777;
      -webkit-box-shadow:0px 0px 10px 3px #777777;
      box-shadow:0px 0px 10px 3px #777777;
    }
    
    .input_editable {
      background: #FFFFFF;
    }
    
    .input_uneditable {
      background: #DDDDDD;
    }
    
    .message_row {
      margin-bottom: 2px;
      background: #eee;
    }
    
    .message_col {
      margin-left: 3px;
    }
    
    .message_time {
      font-weight: bold;
    }
    
    .message_type {
      font-weight: bold;
    }
    
    .message_username {
      font-weight: bold;
      color: blue;
      cursor : pointer;
    }
    
    #chat_tabs {
      background: #ddd;
    }
    
    ul {
      list-style: none;
      padding:0;
      margin:0;
    }
    
    li {
      background: #ddd;
      display: inline;
      border-right: 1px solid #000;
      border-bottom: 1px solid #000;
      cursor: pointer;
      
      padding-right: 5px;
      text-align: center;
      
    }
    li:hover {
      background: #fff;
    }
    .active {
      background: #FF00FF;
    }
    
    .important {
      color: #FF0000;
    }
    </style>
    ''';
    __chat_users = _root.query('#chat_users');
    __iterate_users = __chat_users.query('#iterate_users');
    __t.loop(__iterate_users, () => (users), (user, __t) {
      var __e1;
      __e1 = new autogenerated.Element.html('<div class="user_entry"></div>');
      var __binding0 = __t.contentBind(() => (user.name));
      __e1.nodes.add(__binding0);
      __t.listen(__e1.onDoubleClick, ($event) { onUserDoubleClick($event); });
      __t.addAll([
        new autogenerated.Text('\n                '),
        __e1,
        new autogenerated.Text('\n              ')
      ]);
    });
    __chat_tabs = _root.query('#chat_tabs');
    __iterate_tabs = __chat_tabs.query('#iterate_tabs');
    __t.loop(__iterate_tabs, () => (tabs), (tab, __t) {
      var __e3;
      __e3 = new autogenerated.Element.html('<li class=""></li>');
      var __binding2 = __t.contentBind(() => (tab.name));
      __e3.nodes.add(__binding2);
      __t.listen(__e3.onClick, ($event) { onSetTabActive($event); });
      __t.bindClass(__e3, () => (tab.cssclass));
      __t.addAll([
        new autogenerated.Text('\n                    '),
        __e3,
        new autogenerated.Text('\n                  ')
      ]);
    });
    __chat_messages = _root.query('#chat_messages');
    __e13 = __chat_messages.query('#__e-13');
    __t.conditional(__e13, () => (cansend), (__t) {
      var __iterate_messages;
      __iterate_messages = new autogenerated.Element.html('<template id="iterate_messages" style="display:none"></template>');
      __t.loop(__iterate_messages, () => (messages[activetab]), (message, __t) {
        var __e11, __e12, __e5, __e7, __e9;
        __e12 = new autogenerated.Element.html('<div class="message_row">\n                    <span class="message_col message_time" id="__e-5"></span>\n                    <span class="message_col message_type" id="__e-7"></span>\n                    <span class="message_col message_username" id="__e-9"></span>\n                    <span class="message_col message_message" id="__e-11"></span>\n                  </div>');
        __e5 = __e12.query('#__e-5');
        var __binding4 = __t.contentBind(() => (message.time));
        __e5.nodes.addAll([
          new autogenerated.Text('['),
          __binding4,
          new autogenerated.Text(']')
        ]);
        __e7 = __e12.query('#__e-7');
        var __binding6 = __t.contentBind(() => (message.messageType));
        __e7.nodes.addAll([
          new autogenerated.Text('['),
          __binding6,
          new autogenerated.Text(']')
        ]);
        __e9 = __e12.query('#__e-9');
        var __binding8 = __t.contentBind(() => (message.user));
        __e9.nodes.add(__binding8);
        __t.listen(__e9.onDoubleClick, ($event) { onUserDoubleClick($event); });
        __e11 = __e12.query('#__e-11');
        var __binding10 = __t.contentBind(() => (message.message));
        __e11.nodes.add(__binding10);
        __t.addAll([
          new autogenerated.Text('\n                  '),
          __e12,
          new autogenerated.Text('\n                ')
        ]);
      });
      __t.addAll([
        new autogenerated.Text('\n                '),
        __iterate_messages,
        new autogenerated.Text('\n              ')
      ]);
    });
    
    __chat_input = _root.query('#chat_input');
    __t.listen(__chat_input.onKeyDown, ($event) { onInputKeyDown($event); });
    
    __t.create();
  }
  
  void inserted_autogenerated() {
    __t.insert();
  }
  
  void removed_autogenerated() {
    __t.remove();
    __chat_input = __chat_messages = __chat_tabs = __chat_users = __e13 = __iterate_tabs = __iterate_users = __t = null;
  }
  
  void composeChildren() {
    super.composeChildren();
    if (_root is! autogenerated.ShadowRoot) _root = this;
  }
  
  /** Original code from the component. */
  
  Map<String, List<ChatMessage>> messages = new Map<String, List<ChatMessage>>();
  //List<ChatMessage> messages = new List<ChatMessage>();
  List<User> users = new List<User>();
  List<Tab> tabs = new List<Tab>();
  DivElement chat;
  DivElement input;
  String channel = "abc";
  String connectionstring = "";
  ChannelClient client;
  bool cansend = false;
  String activetab = "SYSTEM";
  final String INPUT_EDITABLE = "input_editable";
  final String INPUT_UNEDITABLE = "input_uneditable";
  final int MESSAGE_LIMIT = 100;
  
  void add(String identifier, ChatMessage m) {
    if (!messages.containsKey(identifier))
    messages[identifier] = new List<ChatMessage>();
    
    if (!tabExists(identifier)) {
      tabs.add(new Tab(identifier));
      activetab = identifier;
    }
    
    messages[identifier].add(m);
    
    // Hihih.. hax?
    window.setTimeout(() {
      chat.scrollTop = chat.scrollHeight;
    }, 100);
  }
  
  void created() {
    new Logger().setLevel(LogLevel.WARN);
  }
  
  void inserted() {
    
    input = query("#chat_input");
    chat = query("#chat_messages");
    input.focus();
    
    client = new ChannelClient(new WebSocketDataSource(connectionstring))
    .setChannel(channel)
    .setRequireAudio(false)
    .setRequireVideo(false)
    .setRequireDataChannel(true);
    
    client.onInitializationStateChangeEvent.listen((InitializationStateEvent e) {
      if (e.state == InitializationState.CHANNEL_READY) {
        //if (client.setChannelLimit(10))
        //add("system", createSystemMessage("Setting channel limit"));
        
        cansend = true;
        setEditable(true);
        dispatch();
      }
    });
    
    client.onSignalingOpenEvent.listen((SignalingOpenEvent e) {
      add("SYSTEM", createSystemMessage("Connected"));
      dispatch();
    });
    
    client.onSignalingCloseEvent.listen((SignalingCloseEvent e) {
      print("Disconnected");
      add("SYSTEM", createSystemMessage("Disconnected"));
      cansend = false;
      setEditable(false);
      dispatch();
      window.setTimeout(() {
        client.initialize();
      }, 10000);
    });
    
    client.onPacketEvent.listen((PacketEvent e) {
      if (e.type == PacketType.CHANNELMESSAGE) {
        ChannelMessage cm = e.packet as ChannelMessage;
        add(cm.channelId, new ChatMessage(new DateTime.now(), MessageType.MESSAGE, cm.id, cm.message));
      } else if (e.type == PacketType.CHANNEL) {
        ChannelPacket cp = e.packet as ChannelPacket;
        add(cp.channelId, createChannelMessage("Channel has ${cp.users} users and has a limit of ${cp.limit} concurrent users"));
      } else if (e.type == PacketType.USERMESSAGE) {
        UserMessage um = e.packet as UserMessage;
        add(um.id, new ChatMessage(new DateTime.now(), MessageType.PRIVATE, um.id, um.message));
      } else if (e.type == PacketType.ID) {
        
        IdPacket id = e.packet as IdPacket;
        users.add(new User(id.id));
      } else if (e.type == PacketType.JOIN) {
        
        JoinPacket join = e.packet as JoinPacket;
        users.add(new User(join.id));
        add(join.channelId, createChannelMessage("${join.id} joins the channel"));
      } else if (e.type == PacketType.BYE) {
        ByePacket bye = e.packet as ByePacket;
        add("bye", createChannelMessage("${bye.id} leaves the channel"));
        for (int i = 0; i < users.length; i++) {
          User u = users[i];
          if (u.name == bye.id)
          users.removeAt(i);
        }
      }
      dispatch();
    });
    
    client.initialize();
  }
  
  void onInputKeyDown(KeyboardEvent e) {
    if (!cansend)
    return;
    
    DivElement i = e.target as DivElement;
    if (e.keyCode == 13) {
      if (i.text.length == 0) {
        i.text = "";
        return;
      }
      ChatEntry entry = new ChatEntry(i.text);
      if (entry.isCommand)  {
        String command = entry.command;
        add("me", new ChatMessage(new DateTime.now(), MessageType.MESSAGE, "me", "Issuing command $command"));
      } else {
        add("me", new ChatMessage(new DateTime.now(), MessageType.MESSAGE, "me", entry.toString()));
        client.sendChannelMessage(entry.toString());
      }
      i.text = "";
    }
  }
  
  void onUserDoubleClick(MouseEvent e) {
    input.focus();
    Element element = e.target;
    
    if (input.text == "")
    input.text = "/msg ${element.text} ";
    
  }
  
  void onSetTabActive(MouseEvent e) {
    Element el = e.target;
    activetab = el.text;
    //tabs.where((Tab t) => t.name == activeTab).first.
    dispatch();
  }
  
  /** Invoked when this component is removed from the DOM tree. */
  void removed() {
    print("Removed");
  }
  
  void setEditable(bool b) {
    if (b) {
      input.contentEditable = "true";
      input.classes.remove(INPUT_UNEDITABLE);
      input.classes.add(INPUT_EDITABLE);
    } else {
      input.contentEditable = "false";
      input.classes.remove(INPUT_EDITABLE);
      input.classes.add(INPUT_UNEDITABLE);
    }
  }
  
  bool tabExists(identifier) {
    return tabs.any((Tab t) => t.name == identifier);
  }
  
  Tab createTab(String name) {
    Tab t = new Tab(name);
    tabs.add(t);
    return t;
  }
  
  ChatMessage createChannelMessage(String m) {
    return new ChatMessage(new DateTime.now(), MessageType.CHANNEL, "CHANNEL", m);
  }
  
  ChatMessage createSystemMessage(String m) {
    return new ChatMessage(new DateTime.now(), MessageType.SYSTEM, "SYSTEM", m);
  }
}

